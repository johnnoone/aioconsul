import logging
from collections import namedtuple

__all__ = ['Token', 'Rule', 'Check', 'Event', 'Member',
           'Node', 'Service', 'NodeService', 'Session',
           'DataSet', 'DataMapping', 'Key']

log = logging.getLogger(__name__)


class Token:
    """
    A token has an ID, a name, a type and a :py:class:`Rule` set.
    The ID is randomly generated by the API, making it unfeasible to guess.
    The name is opaque and human readable. The type is either "client"
    meaning it cannot modify ACL rules, and is restricted by the provided
    rules, or is "management" and is allowed to perform all actions.

    The token ID is passed along with each RPC request to the servers.

    Attributes:
        id (str): token id
        name (str): token name
        type (str): token type
        rules (list): list of token :class:`Rule`
        create_index (int): create index when fetched
        modify_index (int): modify index when fetched
    """

    def __init__(self, id, *, name, type, rules,
                 create_index=None, modify_index=None):
        self.id = id
        self.name = name
        self.type = type
        self.rules = rules or []
        self.create_index = create_index
        self.modify_index = modify_index

    def __iter__(self):
        return iter(self.rules)

    def __eq__(self, other):
        return self.id == other.id

    def __hash__(self):
        return hash(self.id)

    def __repr__(self):
        return '<Token(id=%r, name=%r)>' % (self.id, self.name)


class Rule(namedtuple('Rule_', 'type value policy')):
    """Describe the policy that must be enforced.

    Key policies provide both a prefix and a policy.
    The rules are enforced using a longest-prefix match policy.
    This means we pick the most specific policy possible.
    The policy is either "read", "write" or "deny".

    Services policies provide both a service name and a policy.
    The rules are enforced using an exact match policy.
    The default rule is provided using the empty string.
    The policy is either "read", "write", or "deny".

    Attributes:
        type (str): key or service
        value (str): value of rule
        policy (str): read, write or deny
    """


class Check:
    """
    Attributes:
        id (str): id
        name (str): name
        status (str): status
        notes (str): notes
        output (str): output
        service_id (str): service_id
        service_name (str): service_name
        node (str): node
    """

    def __init__(self, id, *, name, status=None, notes=None,
                 output=None, service_id=None, service_name=None, node=None):
        self.id = id
        self.name = name
        self.status = status
        self.notes = notes
        self.output = output
        self.service_id = service_id
        self.service_name = service_name
        self.node = node

    def __repr__(self):
        return '<Check(id=%r, name=%r)>' % (self.id, self.name)


class Event(object):
    """
    Attributes:
        id (str): id
        name (str): name
        payload (str): payload
        node_filter (str): node_filter
        service_filter (str): service_filter
        tag_filter (str): tag_filter
        version (str): version
        l_time (str): l_time
    """

    def __init__(self, name, *, id=None, payload=None,
                 node_filter=None, service_filter=None, tag_filter=None,
                 version=None, l_time=None):
        self.id = id
        self.name = name
        self.payload = payload
        self.node_filter = node_filter
        self.service_filter = service_filter
        self.tag_filter = tag_filter
        self.version = version
        self.l_time = l_time

    def __eq__(self, other):
        return self.id == other.id

    def __hash__(self):
        return hash(self.id)

    def __repr__(self):
        return '<Event(id=%r, name=%r)>' % (self.id, self.name)


class Member:
    """
    Attributes:
        name (str): name
        address (str): address
        port (int): port
        status (int): status
        tags (dict): tags
        delegate_cur (int): delegate current
        delegate_max (int): delegate maximum
        delegate_min (int): delegate mininum
        protocol_cur (int): protocol current
        protocol_max (int): protocol maximum
        protocol_min (int): protocol mininum
    """

    def __init__(self, name, address, port, **opts):
        self.name = name
        self.address = address
        self.port = port
        self.status = opts.get('status')
        self.tags = opts.get('tags')
        self.delegate_cur = opts.get('delegate_cur')
        self.delegate_max = opts.get('delegate_max')
        self.delegate_min = opts.get('delegate_min')
        self.protocol_cur = opts.get('protocol_cur')
        self.protocol_max = opts.get('protocol_max')
        self.protocol_min = opts.get('protocol_min')

    def __eq__(self, other):
        return self.name == other.name

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return str(self.name)

    def __repr__(self):
        return '<Member(name=%r, address=%r, port=%r)>' % (
            self.name, self.address, self.port)


class Node:
    """
    Attributes:
        name (str): name
        address (str): address
    """

    def __init__(self, name, address):
        self.name = name
        self.address = address

    def __iter__(self):
        if hasattr(self, 'service'):
            return iter([self.service])
        if hasattr(self, 'services'):
            return self.services.values()
        raise TypeError('Does not have service nor services')

    def __eq__(self, other):
        return self.name == other.name

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return str(self.name)

    def __repr__(self):
        return '<Node(name=%r)>' % self.name


class Service:
    """
    Attributes:
        id (str): id
        name (str): name
    """

    def __init__(self, id, *, name):
        self.id = id
        self.name = name

    def __eq__(self, other):
        return self.id == other.id

    def __hash__(self):
        return hash(self.id)

    def __str__(self):
        return str(self.id)

    def __repr__(self):
        return '<Service(id=%r)>' % self.id


class NodeService(Service):
    """A service that belongs to a node.

    Attributes:
        id (str): id
        name (str): name
        address (str): address
        port (int): port
        tags (list): tags
    """

    def __init__(self, id, *, name, address=None, port=None, tags=None):
        Service.__init__(self, id, name=name)
        self.address = address
        self.port = port
        self.tags = tags

    def __repr__(self):
        return '<NodeService(id=%r)>' % self.id


class Session:
    """
    Attributes:
        id (str): session id
        behavior (str): session behavior (delete, release)
        checks (str): session checks
        create_index (str): used for locks
        node (str): attached node
    """

    def __init__(self, id, *, node=None, checks=None,
                 create_index=None, behavior=None):
        self.id = id
        self.behavior = behavior
        self.checks = checks
        self.create_index = create_index
        self.node = node

    def __eq__(self, other):
        return self.id == other.id

    def __hash__(self):
        return hash(self.id)

    def __repr__(self):
        return '<Session(id=%r)>' % self.id


class DataMapping(dict):
    """
    Just a `dict` that holds response headers.

    Attributes:
        modify_index (int): modify index
        last_contact (str): last contact
    """
    
    def __init__(self, values, *, modify_index=None, last_contact=None):
        super(DataMapping, self).__init__(values)
        self.modify_index = modify_index
        self.last_contact = last_contact


class DataSet(set):
    """
    Just a `set` that holds response headers.

    Attributes:
        modify_index (int): modify index
        last_contact (str): last contact
    """
    
    def __init__(self, values, *, modify_index=None, last_contact=None):
        super(DataSet, self).__init__(values)
        self.modify_index = modify_index
        self.last_contact = last_contact


class Key:
    """
    Attributes:
        name (str): key
        session (str): session that acquired this key
        create_index (int): create_index
        lock_index (int): lock_index
        modify_index (int): modify_index
    """
    def __init__(self, name, *, session=None, create_index=None,
                 modify_index=None, lock_index=None):
        self.name = name
        self.session = session
        self.create_index = create_index
        self.modify_index = modify_index
        self.lock_index = lock_index

    def __eq__(self, other):
        return self.name == other.name

    def __hash__(self):
        return hash(self.key)

    def __repr__(self):
        return '<Key(key=%r)>' % self.key


class Config(object):

    class Port(object):

        def __init__(self, *, opts):
            if isinstance(opts, Config.Port):
                pop = lambda src, attr: getattr(src, attr, None)
            else:
                pop = lambda src, attr: src.pop(attr, None)

            self.dns = pop(opts, 'dns')
            self.http = pop(opts, 'http')
            self.rpc = pop(opts, 'rpc')
            self.serf_lan = pop(opts, 'serf_lan')
            self.serf_wan = pop(opts, 'serf_wan')
            self.server = pop(opts, 'server')

    def __init__(self, **opts):

        self.bootstrap = opts.pop('bootstrap', None)
        self.server = opts.pop('server', None)
        self.datacenter = opts.pop('datacenter', None)
        self.data_dir = opts.pop('data_dir', None)
        self.dns_recursor = opts.pop('dns_recursor', None)
        self.dns_recursors = opts.pop('dns_recursors', None)
        self.domain = opts.pop('domain', None)
        self.log_level = opts.pop('log_level', None)
        self.node_name = opts.pop('node_name', None)
        self.client_address = opts.pop('client_address', None)
        self.bind_address = opts.pop('bind_address', None)
        self.advertise_address = opts.pop('advertise_address', None)
        self.port = opts.pop('port', {})
        self.leave_on_term = opts.pop('leave_on_term', None)
        self.skip_leave_on_int = opts.pop('skip_leave_on_int', None)
        self.statsite_address = opts.pop('statsite_address', None)
        self.protocol = opts.pop('protocol', None)
        self.enable_debug = opts.pop('enable_debug', None)
        self.verify_incoming = opts.pop('verify_incoming', None)
        self.verify_outgoing = opts.pop('verify_outgoing', None)
        self.ca_file = opts.pop('ca_file', None)
        self.cert_file = opts.pop('cert_file', None)
        self.key_file = opts.pop('key_file', None)
        self.start_join = opts.pop('start_join', None)
        self.ui_dir = opts.pop('ui_dir', None)
        self.pid_file = opts.pop('pid_file', None)
        self.enable_syslog = opts.pop('enable_syslog', None)
        self.rejoin_after_leave = opts.pop('rejoin_after_leave', None)

        if opts:
            log.warn('Remainings opts %s', opts)
